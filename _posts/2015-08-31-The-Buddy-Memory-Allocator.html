---
　　layout: default
　　title: 一种高效的Buddy Memory Allocator 内存分配策略
---

　　<h2>{{ page.title }}</h2>

	<p> 原文见 <a href="http://bitsquid.blogspot.com/2015/08/allocation-adventures-3-buddy-allocator.html">http://bitsquid.blogspot.com/2015/08/allocation-adventures-3-buddy-allocator.html</a></p>

	<h4>现有的内存分配器：</h4>
	<p> 防止内存片段化的方法一般有：对长期和短期的分配任务采用不同的分配器，所以短期分配器所产生的空洞不会影响到长期内存；<br />
	    对小的内存分配任务单独开辟一个Buffer处理；使内存块可以重定位，例如采用句柄代替指针；从OS申请整个页的内存，然后依赖操作系统来处理 </p>
		
	<p>	目前使用的三种常用技术： in-place linked lists, preambles and postambles </p>
	<p> In-place linked lists is a technique for storing linked lists of free memory blocks without using any extra memory. <br />
		基本想法就是把这个空闲内存块的大小以及前后空闲块的指针存在block内部，因此不需要任何额外存储空间。
		</p>
	<p> A preamble is a little piece of data that sits just before the allocated memory and contains some information about that memory block. <br />
		基本想法就是把这个空闲内存块的信息存在前面的额外内存中。C语言的free代码如下： <br />
	<pre><code>
		void *A = malloc(100);
		------------------------
		| pre |    A     | post|
		------------------------
		</code></pre>	
		
		<pre><code>
			struct Preamble
			{
			    unsigned size;
			    ...
			};

			void free(void *p)
			{
			    Preamble *pre = (Preamble *)p - 1;
			    unsigned size = pre-&gt;size;
			}
		</code></pre>		
	</p>
	<p> 这种方法的问题是额外的存储空间可能会引起内存对齐问题，例如我们想分配4 K 的内存，但OS必须返回8K，为了存储额外的前置内容。</p>
	<p> Postamble技术对于空闲内存块的合并是很容易处理的，只需要向左或向右查询即可获得临近内存块的头指针。</p>
	
	
	<h4>The buddy allocator</h4>
	<p>	基本思路：重复对半切分内存块，创建出两个小的子 "buddies"，直至我们可以得到所需要大小的Block </p>
	<p> block sizes will always be a powers of two, such as:
		<pre><code>Buddy allocator after 32 K allocation:

		    -----------------------------------------------------------------
		512 |                               S                               |
		    -----------------------------------------------------------------
		256 |               S               |               F               |
		    -----------------------------------------------------------------
		128 |       S       |       F       |
		    ---------------------------------
		 64 |   S   |   F   |                        S - split
		    -----------------                        F - free
		 32 | A | F |                                A - allocated
		    ---------
		</code></pre>
		</p>
	<p>	Merging in the buddy allocator 也是超级简单，当一个block释放时，只需要检查它的buddy 是否也是free的，若是，则合并它们。 <br />
		这是一个递归过程， 直至树的根节点。  </p>
	
	<h4>实现细节：</h4>
	<p> we put the free blocks of each size in an implicit linked list. <br />
		To find a free block we just take the first item from the list of blocks of that size, remove it from the list and return it.<br />
		If there is no block of the right size, we take the block of the next higher size and split that. <br />
		 We use one of the two blocks we get and put the other one on the free list for that size. <br />
		 If the list of blocks of the bigger size is also empty, we can go to the even bigger size, etc.<br />
		To make things easier for us, let's introduce the concept of levels. We say that the single block that we start with, representing the entire buffer, is at level 0.<br />
		 When we split that we get two blocks at level 1. Splitting them, we get to level 2, etc.
		<pre><code>	if the list of free blocks at level n is empty
	    			allocate a block at level n-1 (using this algorithm)
	    			split the block into two blocks at level n
	    			insert the two blocks into the list of free blocks for level n
					remove the first block from the list at level n and return it
		</code></pre>
		<pre><code>	static const int MAX_LEVELS = 32;
					void *_free_lists[MAX_LEVELS];
		</code></pre>
		The prev and next pointers for the lists are stored directly in the free blocks themselves. <br />
		We can also note some mathematical properties of the allocator:<br />
		<pre><code>	total_size == (1&lt;&lt;num_levels) * leaf_size
					size_of_level(n) == total_size / (1&lt;&lt;n)
					max_blocks_of_level(n) = (1&lt;&lt;n)
		</code></pre>
		Note that MAX_LEVELS = 32 is probably enough since that gives a total size of leaf_size * 4 GB and we know leaf_size will be at least 16. <br />
		(The leaf nodes must have room for the prev and next pointers of the  linked list and we assume a 64 bit system.)<br />
		Note also that we can create a unique index for each block in the buddy allocator as (1&lt;&lt;level) + index_in_level - 1 . <br />
		The node at level 0 will have index 0. The two nodes at level 1 will have index 1 and 2, etc:
		<pre><code>Block indices is
		
		    -----------------------------------------------------------------
		512 |                               0                               |
		    -----------------------------------------------------------------
		256 |               1               |               2               |
		    -----------------------------------------------------------------
		128 |       3       |       4       |       5       |       6       |
		    -----------------------------------------------------------------
		 64 |   7   |   8   |   9   |  10   |  11   |  12   |  13   |  14   |
		    -----------------------------------------------------------------
		 32 |15 |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |
		    -----------------------------------------------------------------
		</code></pre>
		</p>
		
	<p> What about deallocation? </p>
	<p> First, note that we can easily compute the address of the buddy. Suppose we have free a block p at level n.<br />
		 We can compute the index of that in the level as:
		<pre><code>	index_in_level_of(p,n) == (p - _buffer_start) / size_of_level(n)
		</code></pre>
		
		If the index i is even, then the buddy as at index i+1 and otherwise the buddy is at i-1 and we can use the formula above to solve for the pointer, given the index.<br />
		
		Second, what we can do is to store a bit for each block, telling us if that block is free or allocated.<br />
		
		For each pair of buddies A and B we store the single bit is_A_free XOR is_B_free. <br />
		We can easily maintain the state of that bit by flipping it each time one of the buddies is freed or allocated.<br />		
		When we consider making a merge we know that one of buddies is free, because it is only when a block has just been freed that we consider a merge. <br />	
		This means we can find out the state of the other block from the XORed bit. If it is 0, then both blocks are free. If it is 1 then it is just our block that is free.<br />	
		
		To find the level n of an allocated block we can use the algorithm:
		<pre><code>	n = num_levels - 1
					while n &gt; 0
					    if block_has_been_split(ptr, n-1)
					        return n
					    n = n - 1
					return 0
		</code></pre>
		Since the leaf blocks can't be split, we only need <code>1 &lt;&lt; (num_levels - 1)</code> entries in the split index.<br />
		This means that the cost of the split index is the same as for the merge index, 0.5 bits per block. <br />
		It's a bit amazing that we can do all this with a total overhead of just 1 bit per block. <br />
		<br />
		Where do we store this 1 bit of metadata per block? We could put the metadata in the buffer itself,  <br />
		at the beginning where we can easily find it. We mark the blocks used.
		</p>
		
	<h4> buddy allocator 的增长 </h4>	
		<p> 当buffer需要增长时，我们只需要为这个buddy allocator申请下一个等级的Level ，这样完全避免了internal fragmentation issue， <br />
			  buddy allocator可以完全利用整个空间。</p>
		
	<p>{{ page.date | date_to_string }}</p>
	